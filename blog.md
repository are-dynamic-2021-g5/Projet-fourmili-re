## Travail effectué 


### Semaine 1
 Inscription sur Github et création du blog (Oui ! Celui que vous êtes en train de lire !). Travail documentaire pour mieux cerner les enjeux du projet et affiner la précision du projet à initier. Pour réaliser ce travail documentaire, nous avons effectué  des recherches généralistes dans le but de trouver des mots clés nécéssaires au développement du sujet. Une fois nos mots clés trouvés, nous sommes allés rechercher sur les bases de données informatiques de la Sorbonne, des documents précis, réalisés par des chercheurs pour comprendre de manière précise les tenants du développement de la  fourmilière, et le fonctionnement précis de chacun des acteurs de celle ci. Pour optimiser notre séance, nous avons décidés de séparer le travail entre nous quatre : Nicolas a commencé la modélisation informatique de la fourmilière par la construction d'une matrice basique comprennant la foumilière et un point de nourriture généré aléatoirement, ainsi que par la génération des fourmis exploratrices et les prémices de leur déplacements. Les trois autres membres du groupe se sont scindés pour ratisser un grand nombre d'informations sur les fourmilières à l'aide de différentes bases de données du site de l'université. Après avoir obtenu les documents nécéssaires à une analyse scientifique du sujet, nous avons terminé la séance en complétant le travail de recherche documentaire.


### Semaine 2 
 Réalisation de l'index, travail documentaire et recherches bibliographiques pour préciser le modèle souhaité et la façon de le mettre en place. Conception du code de génération des fourmis, du déplacement aléatoire d'une fourmi ainsi que d'un essaim. Améliorations graphiques et résolution de quelques failles du code.


### Semaine 3
 Mise en place de l'interface graphique Tkinter via l'apprentissage des notions élémentaires de ce langage. Pour cela nous avons appris à réaliser des curseurs ainsi que des boutons tout en gérant l'affichage du canevas positionné à coté de nos curseurs. Nous avons de plus théorisé la représentation d'une matrice sur Tkinter. Nous avons également approfondi nos recherches documentaires sur les phéromones utilisés par les fourmis ainsi que les probabilités de suivi de certains chemins. Enfin, nous avons travaillé sur les fonction permettant aux fourmis de prendre la nourriture et de retrouver leur chemin pour la ramener à la fourmilière.

### Semaine 4
 Importantes réflexions sur la forme du modèle. En effet, les matrices numpy utilisées jusque là regroupaient toutes les informations sur une seule matrice. Cependant, implémentant sans cesse de nouveaux paramètres, nous avons pris conscience de la nécessité d'avoir plusieurs niveaux de lecture de chacune des cases de la matrice représentant la carte. Suite à cela, nous nous sommes questionnés sur le moyen d'enregistrer plusieurs informations sur les cases de notre modèle de manière à ce que le tout soit lisible et que les fonctions créées jusque là soient toujours exploitables. Après avoir considéré l'éventualité d'utiliser le module "dtype" de numpy qui permet d'affecter une liste d'informations à chaque case, nous avons préféré obter pour la création de plusieurs matrices de même taille et représentant chacune un degré de lecture du modèle car la première option, bien que sûrement plus propre, nous aurait obligé à apprendre le fonctionnement d'un nouveau module (tout de même assez complexe), et à revoir entièrement les fonctions déjà effectuées (nous aurions du refonder la matrice de l'espace-temps de notre modèle ! Un travail einsteinesque !). Nous avons donc modifié les fonctions existantes pour ajouter ces matrices.
  Amélioration de la compréhension de Tkinter, ajout de représentations graphiques de certaines fonctions. Après avoir installé les différents curseurs permettant de faire varier les paramètres du modèle, nous nous sommes attelés à représenter la matrice de base de la carte (avec le point de nourriture et la fourmilière), ainsi que les fourmis.
   Organisation pour le rendu final. Nous nous sommes informés sur le travail de rendu final (blog et présentation) et avons étudié quelques rendus des années précédentes pour avoir un aperçu de la tâche. Après quoi, nous avons fait un bilan de ce qu'on avait déjà fait, de ce qu'on voulait encore faire et de comment nous organiser pour y arriver.
   
### Semaine 5
 Refonte du modèle de déplacement des fourmis. En ayant maintenant la possibilité de considérer plusieurs informations sur chaque case il nous a été possible de modifié le déplacement des fourmis et cela de plusieurs manières. Tout d'abord la recherche aléatoire est devenue un peu plus "intelligente" dans le sens où les fourmis ne reviennent pas sur leurs pas avant un certain temps. Ensuite, en étudiant des modèles d'algorithme d'optimisation du chemin de type fourmis nous nous sommes apperçus que les fourmis retrouvaient le chemin de la maison non pas directement comme initialement programmé mais grâce au phéromones qu'elles ont laissées à l'aller. Ainsi, il a fallu programmer la fonction déplacement en tenant en compte de la pause de phéromones, de la différence de comportement entre les fourmis avec et sans nourriture et de la prise et dépôt de nourriture.
  Essais de création d'une fonction faisant apparaitre périodiquement de la nourriture. Nous avons essayé de faire apparaitre de la nourriture aléatoirement de manière périodique mais le code final ne fonctionnait pas à cause d'erreurs de format.
  Essais de représentation de plusieurs matrices sur Tkinter.
  Intégration de pièges dans la carte. Nous avons ajouté des pièges à la carte qui simule des attaques. Ce sont des cases choisies aléatoirement qui "tuent" les fourmis si elles arrivent dessus.
  
### Semaine 6-7-8
 Grandes réflexions sur la manière de faire suivre un chemin de phéromones dans le bon sens. Dire que les fourmis doivent suivre le chemin de phéromones le plus marqué est une chose mais implémenter cela correctement dans le code est une autre affaire... Après beaucoup (vraiment beaucoup...) de tentatives différentes nous avons défini une assez bonne manière pour suivre le chemin de phéromones le plus marqué et dans le bon sens (même si cette méthode ne permet pas d'éviter tous les blocages...).
 Création du facteur d'exploration. Au déplacement classique des fourmis nous avons ajouté un déplacement aléatoire périodique caractéristique des fourmis et qui permet à termes d'optimiser le chemin par la découverte de chemins plus courts que ceux déjà établis (dans notre cas il sert surtout à débloquer certaines situations...).
 Croisement de fourmis. Pour éviter les blocages trop courants nous avons modifié la fonction de déplacement pour permettre le croisement de fourmis.
 Programmation de la simulation. Nous avons enfin réuni toutes les fonctions dans une seule afin de lancer un véritable simulation et...constater que le modèle ne marchait pas vraiment comme prévu...
 Tests et rectification d'erreurs. Pour chaque problème rencontré nous avons étudié les fonctions pouvant être mises en cause, imprimé les variables modifiées pour souvent constater de petites erreurs de copier-coller ou d'inattention. En revanche, certaines fonctions ont dû être entièrement modifiées et d'autres complétées pour prendre en compte le plus de cas possibles et pour coller au mieux à nos attentes.
 Expérimentations. Après trois semaines de travail acharné, nous n'avions pas vraiment obtenu le résultat escompté, à savoir, la création de chemins entre la nourriture et la fourmilière. En simplifiant le modèle, soit, en réduisant la taille de la carte et en ne mettant qu'une fourmi (pour éviter les croisements et la multitude de traces de phéromones...), nous avons réussi à trouver, à force de répétition, quelques expérimentations intéressantes.

<a href="index.html"> Retour à la page principale </a>
